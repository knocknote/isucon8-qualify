package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
	"reflect"
	"sort"

	"github.com/lestrrat-go/msgpack/internal/util"
	"github.com/pkg/errors"
)

func main() {
	if err := _main(); err != nil {
		log.Printf("%s", err)
		os.Exit(1)
	}
}

func _main() error {
	if err := generateNumericEncoders(); err != nil {
		return errors.Wrap(err, `failed to generate numeric encoders`)
	}
	return nil
}

func generateNumericEncoders() error {
	var buf bytes.Buffer

	buf.WriteString("package msgpack")
	buf.WriteString("\n\n// Auto-generated by internal/cmd/genencoder-numeric/genencoder-numeric.go. DO NOT EDIT!")
	buf.WriteString("\n\nimport (")
	buf.WriteString("\n\"math\"")
	buf.WriteString("\n\n\"github.com/pkg/errors\"")
	buf.WriteString("\n)")

	if err := generateIntegerTypes(&buf); err != nil {
		return errors.Wrap(err, `failed to generate integer encoders`)
	}

	if err := generateFloatTypes(&buf); err != nil {
		return errors.Wrap(err, `failed to generate float encoders`)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Println(buf.String())
		return err
	}

	var fn string
	for i := 1; i < len(os.Args); i++ {
		if os.Args[i] != "-" {
			fn = os.Args[i]
			break
		}
	}

	dst, err := os.OpenFile(fn, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
	if err != nil {
		return errors.Wrap(err, `failed to open file`)
	}
	defer dst.Close()

	dst.Write(formatted)
	return nil
}

func generateIntegerTypes(dst io.Writer) error {
	types := map[reflect.Kind]struct {
		Code string
		Bits int
	}{
		reflect.Int:    {Code: "Int64", Bits: 64},
		reflect.Int8:   {Code: "Int8", Bits: 8},
		reflect.Int16:  {Code: "Int16", Bits: 16},
		reflect.Int32:  {Code: "Int32", Bits: 32},
		reflect.Int64:  {Code: "Int64", Bits: 64},
		reflect.Uint:   {Code: "Uint64", Bits: 64},
		reflect.Uint8:  {Code: "Uint8", Bits: 8},
		reflect.Uint16: {Code: "Uint16", Bits: 16},
		reflect.Uint32: {Code: "Uint32", Bits: 32},
		reflect.Uint64: {Code: "Uint64", Bits: 64},
	}

	keys := make([]reflect.Kind, 0, len(types))
	for k := range types {
		keys = append(keys, k)
	}
	sort.Slice(keys, func(i, j int) bool {
		return uint(keys[i]) < uint(keys[j])
	})
	for _, typ := range keys {
		data := types[typ]
		fmt.Fprintf(dst, "\n\nfunc (e *Encoder) Encode%s(v %s) error {", util.Ucfirst(typ.String()), typ)
		switch typ {
		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
			fmt.Fprintf(dst, "\nif inPositiveFixNumRange(int64(v)) {")
			fmt.Fprintf(dst, "\nreturn e.encodePositiveFixNum(uint8(0xff & v))")
			fmt.Fprintf(dst, "\n}")
		case reflect.Int8:
			fmt.Fprintf(dst, "\nif inNegativeFixNumRange(int64(v)) {")
			fmt.Fprintf(dst, "\nreturn e.encodeNegativeFixNum(v)")
			fmt.Fprintf(dst, "\n}")
		default:
			fmt.Fprintf(dst, "\nif inNegativeFixNumRange(int64(v)) {")
			fmt.Fprintf(dst, "\nreturn e.encodeNegativeFixNum(int8(byte(0xff &v)))")
			fmt.Fprintf(dst, "\n}")
		}

		fmt.Fprintf(dst, "\n\nif err := e.dst.WriteByteUint%d(%s.Byte(), ", data.Bits, data.Code)
		switch typ {
		case reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
			fmt.Fprintf(dst, "v")
		default:
			fmt.Fprintf(dst, "uint%d(v)", data.Bits)
		}
		fmt.Fprintf(dst, "); err != nil {")
		fmt.Fprintf(dst, "\nreturn errors.Wrap(err, `msgpack: failed to write %s`)", data.Code)
		fmt.Fprintf(dst, "\n}")
		fmt.Fprintf(dst, "\nreturn nil")
		fmt.Fprintf(dst, "\n}")
	}
	return nil
}

func generateFloatTypes(dst io.Writer) error {
	types := map[reflect.Kind]struct {
		Code string
		Bits int
	}{
		reflect.Float32: {Code: "Float", Bits: 32},
		reflect.Float64: {Code: "Double", Bits: 64},
	}

	keys := make([]reflect.Kind, 0, len(types))
	for k := range types {
		keys = append(keys, k)
	}
	sort.Slice(keys, func(i, j int) bool {
		return uint(keys[i]) < uint(keys[j])
	})
	for _, typ := range keys {
		data := types[typ]
		fmt.Fprintf(dst, "\n\nfunc (e *Encoder) EncodeFloat%d(f float%d) error {", data.Bits, data.Bits)
		fmt.Fprintf(dst, "\nif err := e.dst.WriteByteUint%d(%s.Byte(), math.Float%dbits(f)); err != nil {", data.Bits, data.Code, data.Bits)
		fmt.Fprintf(dst, "\nreturn errors.Wrap(err, `msgpack: failed to write %s`)", data.Code)
		fmt.Fprintf(dst, "\n}")
		fmt.Fprintf(dst, "\nreturn nil")
		fmt.Fprintf(dst, "\n}")
	}
	return nil
}
